import connectDB from './config/db.js';
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import rateLimit from 'express-rate-limit';
import { GoogleGenerativeAI } from '@google/generative-ai';
import { notFound, errorHandler } from './middleware/errorMiddleware.js';
import authRoutes from './routes/authRoutes.js';

dotenv.config();

// Connect to MongoDB
// connectDB(); // Moved to startServer

const app = express();
app.use(express.json({ limit: '1mb' }));
app.use(cors());

const GEMINI_API_KEY = process.env.GEMINI_API_KEY || process.env.REACT_APP_GEMINI_API_KEY || '';

if (!GEMINI_API_KEY) {
  console.error('WARNING: No GEMINI_API_KEY found in environment variables!');
}

const genAI = new GoogleGenerativeAI(GEMINI_API_KEY);
// Use gemini-flash-latest for the best available Flash model
const model = genAI.getGenerativeModel({ model: "gemini-flash-latest" });

const limiter = rateLimit({ windowMs: 60 * 1000, max: 60 });
app.use('/api/', limiter);

// ... (Keep existing AI routes logic) ...

// Routes
app.use('/api/users', authRoutes);

const stripFences = (text) => (text || '').replace(/```json\n?|```/g, '').trim();

const parseJsonSafe = (text, fallback) => {
  try {
    const t = stripFences(text);
    return JSON.parse(t);
  } catch {
    return fallback;
  }
};

const callGemini = async (systemPrompt, userPrompt, { temperature = 0.2, maxTokens = 1000 } = {}) => {
  try {
    // Combine system and user prompt for robust single-turn generation
    const finalPrompt = `${systemPrompt}\n\n${userPrompt}`;

    const result = await model.generateContent({
      contents: [{ role: 'user', parts: [{ text: finalPrompt }] }],
      generationConfig: {
        temperature,
        maxOutputTokens: maxTokens,
      }
    });

    const response = await result.response;
    const text = response.text();
    return text || '';
  } catch (err) {
    console.error('Gemini API error:', err.message);
    if (err.response) {
      console.error('Error response:', JSON.stringify(err.response, null, 2));
    }
    throw err;
  }
};

// Mock Data for Fallbacks
const MOCK_DATA = {
  glossary: [
    { term: 'React', definition: 'A JavaScript library for building user interfaces.' },
    { term: 'Component', definition: 'Independent and reusable bits of code.' },
    { term: 'State', definition: 'An object that determines how that component renders & behaves.' }
  ],
  summary: 'This is a simulated summary generated by the backend because the AI service is currently unavailable. It demonstrates how the UI handles content.',
  tags: ['Productivity', 'Ideas', 'Planning', 'Draft', 'Important'],
  grammar: [
    { text: 'teh', suggestion: 'the' },
    { text: 'recieve', suggestion: 'receive' }
  ],
  actions: ['Review this note', 'Follow up on key points'],
  sentiment: 'Positive',
  chat: 'I am a simulated AI response. The real AI service is currently unavailable, but I am here to demonstrate the chat interface.'
};

app.post('/api/ai/glossary', async (req, res) => {
  try {
    const { content } = req.body || {};
    if (!content || !content.trim()) return res.json([]);

    const systemPrompt = 'Return ONLY a JSON array of objects with "term" and "definition" fields. Maximum 10 terms. No additional text or explanation.';
    const userPrompt = `Identify key terms with brief definitions for this text:\n\n${content}`;

    const text = await callGemini(systemPrompt, userPrompt, { temperature: 0.3, maxTokens: 600 });
    const parsed = parseJsonSafe(text, []);
    const normalized = Array.isArray(parsed) ? parsed.filter(x => x && x.term && x.definition).slice(0, 10) : [];
    res.json(normalized.length > 0 ? normalized : MOCK_DATA.glossary);
  } catch (err) {
    console.error('Glossary error (using mock):', err.message);
    res.json(MOCK_DATA.glossary);
  }
});

app.post('/api/ai/summary', async (req, res) => {
  try {
    const { content } = req.body || {};
    if (!content || !content.trim()) return res.json({ summary: '' });

    const systemPrompt = 'Return ONLY a concise 1-2 sentence summary as plain text. No additional formatting or explanation.';
    const userPrompt = `Summarize in 1-2 sentences:\n\n${content}`;

    const text = await callGemini(systemPrompt, userPrompt, { temperature: 0.3, maxTokens: 200 });
    res.json({ summary: (text || '').trim() });
  } catch (err) {
    console.error('Summary error (using mock):', err.message);
    res.json({ summary: MOCK_DATA.summary });
  }
});

app.post('/api/ai/tags', async (req, res) => {
  try {
    const { content } = req.body || {};
    if (!content || !content.trim()) return res.json([]);

    const systemPrompt = 'Return ONLY a JSON array of 3-5 short tags as strings. No additional text or explanation.';
    const userPrompt = `Generate 3-5 relevant tags for this text:\n\n${content}`;

    const text = await callGemini(systemPrompt, userPrompt, { temperature: 0.2, maxTokens: 200 });
    const parsed = parseJsonSafe(text, []);
    const normalized = Array.isArray(parsed) ? parsed.filter(t => typeof t === 'string').slice(0, 5) : [];
    res.json(normalized.length > 0 ? normalized : MOCK_DATA.tags);
  } catch (err) {
    console.error('Tags error (using mock):', err.message);
    res.json(MOCK_DATA.tags);
  }
});

app.post('/api/ai/grammar', async (req, res) => {
  try {
    const { content } = req.body || {};
    if (!content || !content.trim()) return res.json([]);

    const systemPrompt = 'Return ONLY a JSON array of objects with "text" (the error) and "suggestion" (the correction) fields. No indexes or additional text.';
    const userPrompt = `Identify grammatical errors and provide corrected suggestions:\n\n${content}`;

    const text = await callGemini(systemPrompt, userPrompt, { temperature: 0.1, maxTokens: 800 });
    const parsed = parseJsonSafe(text, []);
    const normalized = Array.isArray(parsed) ? parsed.filter(x => x && x.text && x.suggestion).slice(0, 50) : [];
    res.json(normalized.length > 0 ? normalized : MOCK_DATA.grammar);
  } catch (err) {
    console.error('Grammar error (using mock):', err.message);
    res.json(MOCK_DATA.grammar);
  }
});

app.post('/api/ai/actions', async (req, res) => {
  try {
    const { content } = req.body || {};
    if (!content || !content.trim()) return res.json([]);

    const systemPrompt = 'Return ONLY a JSON array of action items strings. No additional text.';
    const userPrompt = `Extract action items from this text:\n\n${content}`;

    const text = await callGemini(systemPrompt, userPrompt, { temperature: 0.2, maxTokens: 400 });
    const parsed = parseJsonSafe(text, []);
    const normalized = Array.isArray(parsed) ? parsed.filter(t => typeof t === 'string') : [];
    res.json(normalized.length > 0 ? normalized : MOCK_DATA.actions);
  } catch (err) {
    console.error('Actions error (using mock):', err.message);
    res.json(MOCK_DATA.actions);
  }
});

app.post('/api/ai/sentiment', async (req, res) => {
  try {
    const { content } = req.body || {};
    if (!content || !content.trim()) return res.json({ sentiment: 'Neutral' });

    const systemPrompt = 'Return ONLY one word: Positive, Negative, or Neutral.';
    const userPrompt = `Analyze the sentiment of this text:\n\n${content}`;

    const text = await callGemini(systemPrompt, userPrompt, { temperature: 0.1, maxTokens: 10 });
    res.json({ sentiment: (text || 'Neutral').trim() });
  } catch (err) {
    console.error('Sentiment error (using mock):', err.message);
    res.json({ sentiment: MOCK_DATA.sentiment });
  }
});

app.post('/api/ai/chat', async (req, res) => {
  try {
    const { content, query } = req.body || {};
    if (!content || !query) return res.json({ response: '' });

    const systemPrompt = 'You are a helpful AI assistant. Answer the user query based on the provided note content.';
    const userPrompt = `Note Content:\n${content}\n\nUser Query: ${query}`;

    const text = await callGemini(systemPrompt, userPrompt, { temperature: 0.5, maxTokens: 500 });
    res.json({ response: text || '' });
  } catch (err) {
    console.error('Chat error (using mock):', err.message);
    res.json({ response: MOCK_DATA.chat });
  }
});

// Mock Quiz Data
MOCK_DATA.quiz = {
  title: 'Mock Quiz: React Basics',
  questions: [
    {
      question: 'What is a Component in React?',
      options: ['A function or class', 'A database', 'A server', 'A variable'],
      correctAnswer: 0,
      hint: 'Think of it as a building block of the UI.'
    },
    {
      question: 'What hook is used for side effects?',
      options: ['useState', 'useEffect', 'useContext', 'useReducer'],
      correctAnswer: 1,
      hint: 'It runs after the render.'
    }
  ]
};

app.post('/api/ai/quiz/generate', async (req, res) => {
  try {
    const { topic, subject, numQuestions = 5, gradeLevel = 'General' } = req.body || {};
    if (!topic) return res.json(MOCK_DATA.quiz);

    const systemPrompt = `You are an expert academic quiz generator. Create a challenging, high-quality multiple-choice quiz.
    
    RULES:
    1. Return ONLY a JSON object.
    2. Structure: { "title": "Creative Title", "questions": [ { "question": "Question text", "options": ["A", "B", "C", "D"], "correctAnswer": 0-3, "hint": "Helpful hint" } ] }
    3. STRICTLY adhere to the provided "Topic" and "Subject". Do not generate questions outside this scope.
    4. Options must be plausible distractors.
    5. Avoid generic questions like "What is [Topic]?". Use scenarios, application-based, or conceptual questions.
    6. Ensure the "correctAnswer" index matches the correct option.
    7. If the topic is obscure, provide the best possible questions based on general knowledge of the term.
    `;

    const userPrompt = `Create a ${numQuestions}-question ${gradeLevel} level quiz.
    Subject: "${subject}"
    Topic: "${topic}"
    
    Ensure all questions are directly related to "${topic}" within the context of "${subject}".`;

    const text = await callGemini(systemPrompt, userPrompt, { temperature: 0.5, maxTokens: 2000 });
    const parsed = parseJsonSafe(text, null);

    if (parsed) {
      res.json(parsed);
    } else {
      throw new Error('Failed to parse Gemini response');
    }
  } catch (err) {
    console.error('Quiz generation error:', err.message);

    // Dynamic Mock Fallback
    const { topic, subject } = req.body || {};
    const mockQuiz = {
      title: `(Mock) ${subject}: ${topic} Quiz`,
      questions: [
        {
          question: `What is a key concept of ${topic}?`,
          options: [`Understanding ${topic}`, 'Rocket Science', 'Cooking', 'Painting'],
          correctAnswer: 0,
          hint: `Focus on the definition of ${topic}.`
        },
        {
          question: `Which of these relates to ${subject}?`,
          options: ['Apples', `The study of ${topic}`, 'Cars', 'Shoes'],
          correctAnswer: 1,
          hint: 'Think about the subject matter.'
        },
        {
          question: 'True or False: This is a generated fallback quiz.',
          options: ['True', 'False', 'Maybe', 'Unknown'],
          correctAnswer: 0,
          hint: 'The API key might be missing or invalid.'
        }
      ]
    };

    res.json(mockQuiz);
  }
});

app.post('/api/ai/quiz/hint', async (req, res) => {
  try {
    const { question, subject } = req.body || {};
    if (!question) return res.json({ hint: 'No hint available.' });

    const systemPrompt = 'Return ONLY a short, helpful hint string. Do not give the answer directly.';
    const userPrompt = `Provide a hint for this ${subject} question: "${question}"`;

    const text = await callGemini(systemPrompt, userPrompt, { temperature: 0.3, maxTokens: 100 });
    res.json({ hint: (text || 'Think about the core concepts.').trim() });
  } catch (err) {
    console.error('Hint generation error (using mock):', err.message);
    res.json({ hint: 'Review the topic key terms.' });
  }
});

import noteRoutes from './routes/noteRoutes.js';

import quizRoutes from './routes/quizRoutes.js';

import analyticsRoutes from './routes/analyticsRoutes.js';

// Real Auth Routes
app.use('/api/users', authRoutes);
app.use('/api/notes', noteRoutes);
app.use('/api/quizzes', quizRoutes);
app.use('/api/analytics', analyticsRoutes);

// Error Handling Middleware
app.use(notFound);
app.use(errorHandler);

const startServer = async () => {
  try {
    // Connect to MongoDB
    await connectDB();

    const port = process.env.PORT || 5001;
    app.listen(port, () => {
      console.log(`AI backend listening on http://localhost:${port}`);
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();